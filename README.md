# <a HACKING: THE ART OF EXPLOITATION by Jon Erickson > #



# <Introduction 0x100>
    
  <Hacking is really just the act of finding a clever and counterintuitive solution to a problem.> 
  ->Understanding hacking techniques is often difficult, since it requires both breadth and depth of knowledge.
  
  ->The essence of hacking is finding unintended or overlooked uses for the laws and properties of a given situation and then applying them in new and inventive ways to solve a problem—whatever it may be.
  
  <The following math problem illustrates the essence of hacking:>
  ->Use each of the numbers 1, 3, 4, and 6 exactly once with any often the four basic math operations (addition, subtraction, multiplication, and division) to total 24. 
  ->Each number must be used once and only once, and you may define the order of operations; for example, 3 * (4 + 6) + 1 = 31 is valid, however incorrect, since it doesn’t total 24
  
  ->Like the solution to this problem , <hacked solutions follow the rules of the system, but they use those rules in counterintuitive ways.>
  
  ->This gives hackers their edge, allowing them to 
  solve problems in ways unimaginable for those confined  to conventional them  thinking and methodologies

  ->Since the infancy of computers, hackers have been creatively solving problems. In the late 1950s, the MIT model railroad club was given a donation of parts, mostly old telephone equipment. The club’s members used this equipment to rig up a complex system that allowed multiple operators to control different parts of the track by dialing in to the appropriate sections. 
  
  ->They called this <new and inventive use of telephone equipment hacking >; many people consider this group to be the original hackers. The group moved on to programming on punch cards and ticker tape for early computers like the IBM 704 and the TX-0. While others were content with writing programs that just solved problems, the early hackers were obsessed   with writing programs that solved problems well. 

  ->A new program that could achieve the same result as an existing one but used fewer punch cards was considered better, even though it did the same thing. The key difference was how the program achieved its results<elegance.>
  
  ->Being able to reduce the number of punch cards needed for a program showed an artistic mastery over the computer

  ->Like many other forms of art, hacking was often misunderstood. The few who got it formed an informal subculture that remained intensely focused on learning and mastering their art. They believed that information should be free and anything that stood in the way of that freedom should be circumvented. Such obstructions included authority figures, the bureaucracy of college classes, and discrimination.

  -> Age, race, gender, appearance, academic degrees, and social status were not primary criteria for judging another’s worth—not because of a desire for equality, but because of a desire to advance the emerging art of hacking

  ->The spirit of the hacker transcends governmental laws, as opposed to being defined by them even When laws seem to interfere with free speech.

  ->There’s nothing good or bad about knowledge itself; morality lies in the application of knowledge.
  
  <Hackers will constantly be pushing the limits of knowledge and acceptable behavior, forcing us to explore further and further.>
  
  ->Part of this drive results in an ultimately beneficial co-evolution of security through competition between attacking hackers and defending hackers.

  ->The net result of this interaction is positive, as it produces smarter people, improved security, more stable software, inventive problem-solving techniques, and even a new economy


#  <Programming 0x200>
  ->Hacker is a term for both those who <write code and those who exploit it. Even though these two groups of hackers have different end goals, both groups use similar problem-solving techniques.> 
  ->Since an understanding of programming helps those who exploit, and an understanding of exploitation helps those who program, many hackers do both.

  ->The hacks found in program exploits usually use the rules of the computer to bypass security in ways never intended. 
  ->Programming hacks are similar in that they also use the rules of the computer in new and inventive ways, but the final goal is efficiency or smaller source code, not necessarily a security compromise. 
  
  ->In the business world, <more importance is placed on churning out functional code than on achieving clever hacks and elegance>. Because of the tremendous exponential growth of computational power and memory, spending an extra five hours to create a slightly faster and more memory efficient piece of code just doesn’t make business sense when dealing with modern computers that have gigahertz of processing cycles and gigabytes of memory.

  <True appreciation of programming elegance> is left for the hackers: computer hobbyists whose end goal isn’t to make a profit but to squeeze every possible bit of functionality out of their old Commodore 64s, exploit writers who need to <write tiny and amazing pieces of code to slip through narrow security cracks,> and anyone else who appreciates the pursuit and the challenge of finding the best possible solution.
  
  ->These are the people who get excited about programming and really appreciate the beauty of an elegant piece of code or the ingenuity of a clever hack.
  
  <Programming is a very natural and intuitive concept. A program is nothing more than a series of statements written in a specific language>. Programs are everywhere, and even the technophobes of the world use programs every day. Driving directions, cooking recipes, football plays, and DNA are all types of programs    

  ->But a computer doesn’t natively understand English; it only understands machine language. 
  ->To instruct a computer to do something, the instructions must be written in its language.
  ->What’s needed to overcome the complication of writing machine language is a <translator.>
  
  <An assembler> is one form of machine-language translator—it is a program that translates assembly language into machine-readable code.>

  ->Assembly language is still far from intuitive. The instruction names are very esoteric, and the language is architecture specific.
  
  ->Any program written using assembly language for one processor’s architecture will not work on another processor’s architecture.

  ->These problems can be mitigated by yet another form of translator called a compiler. 

  <A compiler converts a high-level language into machine language. High-level languages are much more intuitive than assembly language and can be converted into many different types of machine language for different processor architectures.> 
  
  ->This means that if a program is written in a high level language, the program only needs to be written once; the same piece of program code can becompiled into machine language for various specific architectures.

  ->Without <control structures>, a program would just be a series of instructions executed in sequential order. This is fine for very simple programs, but most programs, like the driving directions example, aren’t that simple

  ->Control structures inlcude,<a If-Then-Else,While/Until Loops, and For Loops>

# <Exploitation 0x300 >
# <Networking 0x400>
# <Shellcode 0x500 >
# <Countermeasures 0x600 >
# <Cryptology 0x700 >
# <Conclusion 0x800 > 

